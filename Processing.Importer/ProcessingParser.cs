// created by jay 0.7 (c) 1998 Axel.Schreiner@informatik.uni-osnabrueck.de

#line 5 "ProcessingParser.jay"
using System;
using System.IO;
using System.Collections.Generic;
using ProcessingCli;
using ProcessingCli.Ast;

// Reference to MBR is generated by jay, but it is not supported in 2.1 corlib.
using MarshalByRefObject = System.Object;

namespace ProcessingCli.Parser
{

	public class ProcessingParser
	{
		ProcessingProjectSource source;
		int yacc_verbose_flag;

		public ProcessingParser (ProcessingProjectSource source)
		{
			this.source = source;
			Roots = new List<AstRoot> ();
		}

		public List<AstRoot> Roots { get; private set; }

		public void Parse ()
		{
			foreach (var uri in source.Sources) {
				var tr = source.OpenInput (uri);
				var t = new Tokenizer (uri, tr);
				try {
					//Roots.Add ((AstRoot) yyparse (t, new yydebug.yyDebugSimple ()));
					Roots.Add ((AstRoot) yyparse (t));
				} catch (yyParser.yyException ex) {
					throw new ParserException (String.Format ("Irrecoverable syntax error at {0}", t.Location), ex);
				}
			}
		}
#line default

  /** error output stream.
      It should be changeable.
    */
  public System.IO.TextWriter ErrorOutput = System.Console.Out;

  /** simplified error message.
      @see <a href="#yyerror(java.lang.String, java.lang.String[])">yyerror</a>
    */
  public void yyerror (string message) {
    yyerror(message, null);
  }

  /* An EOF token */
  public int eof_token;

  /** (syntax) error message.
      Can be overwritten to control message format.
      @param message text to be displayed.
      @param expected vector of acceptable tokens, if available.
    */
  public void yyerror (string message, string[] expected) {
    if ((yacc_verbose_flag > 0) && (expected != null) && (expected.Length  > 0)) {
      ErrorOutput.Write (message+", expecting");
      for (int n = 0; n < expected.Length; ++ n)
        ErrorOutput.Write (" "+expected[n]);
        ErrorOutput.WriteLine ();
    } else
      ErrorOutput.WriteLine (message);
  }

  /** debugging support, requires the package jay.yydebug.
      Set to null to suppress debugging messages.
    */
//t  internal yydebug.yyDebug debug;

  protected const int yyFinal = 23;
//t // Put this array into a separate class so it is only initialized if debugging is actually used
//t // Use MarshalByRefObject to disable inlining
//t class YYRules : MarshalByRefObject {
//t  public static readonly string [] yyRule = {
//t    "$accept : top_level_contents",
//t    "identifier : IDENTIFIER",
//t    "top_level_contents :",
//t    "top_level_contents : top_level_content top_level_contents",
//t    "top_level_content : statement",
//t    "top_level_content : class_declaration",
//t    "top_level_content : global_function_definition",
//t    "global_function_definition : function_definition",
//t    "class_declaration : CLASS identifier opt_derivation_indication opt_implementation_indications OPEN_CURLY class_member_definitions CLOSE_CURLY",
//t    "opt_derivation_indication :",
//t    "opt_derivation_indication : derivation_indication",
//t    "opt_implementation_indications :",
//t    "opt_implementation_indications : implementation_indications",
//t    "derivation_indication : EXTENDS type_name",
//t    "implementation_indications : IMPLEMENTS type_list",
//t    "type_list : type_name",
//t    "type_list : type_name COMMA type_list",
//t    "class_member_definitions :",
//t    "class_member_definitions : class_member_definitions class_member_definition",
//t    "class_member_definition : field_definition",
//t    "class_member_definition : constructor_definition",
//t    "class_member_definition : function_definition",
//t    "field_definition : variable_declaration SEMICOLON",
//t    "constructor_definition : function_definition_base",
//t    "function_definition : type_name function_definition_base",
//t    "function_definition_base : identifier OPEN_PAREN opt_argument_definitions CLOSE_PAREN statement_block",
//t    "opt_argument_definitions :",
//t    "opt_argument_definitions : argument_definitions",
//t    "argument_definitions : argument_definition",
//t    "argument_definitions : argument_definitions COMMA argument_definition",
//t    "argument_definition : type_name identifier",
//t    "statement_block : OPEN_CURLY statements CLOSE_CURLY",
//t    "statements :",
//t    "statements : statement statements",
//t    "statement : statement_with_semicolon SEMICOLON",
//t    "statement : statement_without_semicolon",
//t    "statement_with_semicolon : return_statement",
//t    "statement_with_semicolon : variable_declaration_statement",
//t    "statement_with_semicolon : call_super_statement",
//t    "statement_with_semicolon : break_statement",
//t    "statement_with_semicolon : continue_statement",
//t    "statement_with_semicolon : flow_control_less_statement",
//t    "flow_control_less_statement : abstract_assignment_statement",
//t    "flow_control_less_statement : callable_expression",
//t    "statement_without_semicolon : if_statement",
//t    "statement_without_semicolon : for_statement",
//t    "statement_without_semicolon : while_statement",
//t    "statement_without_semicolon : switch_statement",
//t    "abstract_assignment_statement : assignment_statement",
//t    "abstract_assignment_statement : add_assignment_statement",
//t    "abstract_assignment_statement : subtract_assignment_statement",
//t    "abstract_assignment_statement : multiply_assignment_statement",
//t    "abstract_assignment_statement : divide_assignment_statement",
//t    "abstract_assignment_statement : modulo_assignment_statement",
//t    "add_assignment_statement : prefixed_unary_expression PLUS_EQUAL expression",
//t    "subtract_assignment_statement : prefixed_unary_expression MINUS_EQUAL expression",
//t    "multiply_assignment_statement : prefixed_unary_expression ASTERISK_EQUAL expression",
//t    "divide_assignment_statement : prefixed_unary_expression SLASH_EQUAL expression",
//t    "modulo_assignment_statement : prefixed_unary_expression PERCENT_EQUAL expression",
//t    "increment_expression : variable_or_member_reference PLUS2",
//t    "decrement_expression : variable_or_member_reference MINUS2",
//t    "call_super_statement : SUPER OPEN_PAREN function_args CLOSE_PAREN",
//t    "return_statement : RETURN expression",
//t    "assignment_statement : assignment_expression",
//t    "assignment_expression : prefixed_unary_expression EQUAL expression",
//t    "while_statement : WHILE OPEN_PAREN expression CLOSE_PAREN statement_block",
//t    "break_statement : BREAK",
//t    "continue_statement : CONTINUE",
//t    "variable_declaration_statement : variable_declaration",
//t    "variable_declaration : type_name variable_declaration_pairs",
//t    "type_name : identifier opt_array_indicators",
//t    "opt_array_indicators :",
//t    "opt_array_indicators : array_indicators",
//t    "array_indicators : array_indicator",
//t    "array_indicators : array_indicators array_indicator",
//t    "array_indicator : OPEN_BRACE_CLOSE_BRACE",
//t    "variable_declaration_pairs : variable_declaration_pair",
//t    "variable_declaration_pairs : variable_declaration_pairs COMMA variable_declaration_pair",
//t    "variable_declaration_pair : identifier opt_variable_initializer",
//t    "opt_variable_initializer :",
//t    "opt_variable_initializer : EQUAL array_initializer",
//t    "opt_variable_initializer : EQUAL expression",
//t    "array_initializer : OPEN_CURLY opt_expression_list_comma CLOSE_CURLY",
//t    "opt_expression_list_comma :",
//t    "opt_expression_list_comma : expression_list_comma",
//t    "expression_list_comma : expression",
//t    "expression_list_comma : expression_list_comma COMMA expression",
//t    "single_or_blocked_statements : statement",
//t    "single_or_blocked_statements : statement_block",
//t    "if_statement : IF OPEN_PAREN expression CLOSE_PAREN single_or_blocked_statements opt_else_block",
//t    "opt_else_block :",
//t    "opt_else_block : else_block",
//t    "else_block : ELSE if_statement",
//t    "else_block : ELSE single_or_blocked_statements",
//t    "for_statement : FOR OPEN_PAREN opt_for_initializers SEMICOLON expression SEMICOLON for_continuation CLOSE_PAREN statement_block",
//t    "opt_for_initializers :",
//t    "opt_for_initializers : for_initializers",
//t    "for_initializers : for_initializer",
//t    "for_initializers : for_initializers COMMA for_initializer",
//t    "for_initializer : variable_declaration_statement",
//t    "for_initializer : abstract_assignment_statement",
//t    "for_continuation :",
//t    "for_continuation : flow_control_less_statement",
//t    "switch_statement : SWITCH OPEN_PAREN expression CLOSE_PAREN OPEN_CURLY switch_case_list CLOSE_CURLY",
//t    "switch_case_list :",
//t    "switch_case_list : switch_case_default switch_case_list",
//t    "switch_case_default : switch_case",
//t    "switch_case_default : switch_default",
//t    "switch_case : CASE constant_expression COLON statements",
//t    "switch_default : DEFAULT COLON statements",
//t    "expression : unary_expression",
//t    "expression : conditional_expression",
//t    "expression : super_expression",
//t    "unary_expression : primary_expression",
//t    "unary_expression : logical_not_expression",
//t    "unary_expression : cast_expression",
//t    "prefixed_unary_expression : unary_expression",
//t    "prefixed_unary_expression : MINUS prefixed_unary_expression",
//t    "primary_expression : variable_or_member_reference",
//t    "primary_expression : constant_expression",
//t    "primary_expression : null_expression",
//t    "primary_expression : field_access_expression",
//t    "primary_expression : callable_expression",
//t    "primary_expression : this_expression",
//t    "primary_expression : new_expression",
//t    "primary_expression : array_access_expression",
//t    "primary_expression : parenthesized_expression",
//t    "constant_expression : raw_literal",
//t    "constant_expression : color_literal",
//t    "variable_or_member_reference : identifier",
//t    "new_expression : new_object_expression",
//t    "new_expression : new_array_expression",
//t    "new_object_expression : NEW function_call_base",
//t    "new_array_expression : NEW type_name new_array_ranks",
//t    "new_array_ranks : new_array_rank",
//t    "new_array_ranks : new_array_ranks new_array_rank",
//t    "new_array_rank : OPEN_BRACE expression CLOSE_BRACE",
//t    "new_array_rank : OPEN_BRACE_CLOSE_BRACE",
//t    "callable_expression : function_call_expression",
//t    "callable_expression : function_access_expression",
//t    "callable_expression : increment_expression",
//t    "callable_expression : decrement_expression",
//t    "function_call_expression : function_call_base",
//t    "function_call_base : identifier OPEN_PAREN function_args CLOSE_PAREN",
//t    "function_args :",
//t    "function_args : function_arg_list",
//t    "function_arg_list : expression",
//t    "function_arg_list : expression COMMA function_arg_list",
//t    "raw_literal : string_literal",
//t    "raw_literal : character_literal",
//t    "raw_literal : numeric_literal",
//t    "raw_literal : true_expression",
//t    "raw_literal : false_expression",
//t    "true_expression : TRUE",
//t    "false_expression : FALSE",
//t    "numeric_literal : NUMERIC_LITERAL",
//t    "string_literal : STRING_LITERAL",
//t    "color_literal : COLOR_LITERAL",
//t    "character_literal : CHARACTER_LITERAL",
//t    "additive_expression : multiplicative_expression",
//t    "additive_expression : additive_expression PLUS multiplicative_expression",
//t    "additive_expression : additive_expression MINUS multiplicative_expression",
//t    "multiplicative_expression : prefixed_unary_expression",
//t    "multiplicative_expression : multiplicative_expression ASTERISK prefixed_unary_expression",
//t    "multiplicative_expression : multiplicative_expression SLASH prefixed_unary_expression",
//t    "multiplicative_expression : multiplicative_expression PERCENT prefixed_unary_expression",
//t    "field_access_expression : primary_expression DOT identifier",
//t    "function_access_expression : primary_expression DOT function_call_base",
//t    "super_expression : SUPER",
//t    "this_expression : THIS",
//t    "array_access_expression : primary_expression OPEN_BRACE expression CLOSE_BRACE",
//t    "null_expression : NULL",
//t    "parenthesized_expression : OPEN_PAREN expression CLOSE_PAREN",
//t    "cast_expression : OPEN_PAREN type_name CLOSE_PAREN prefixed_unary_expression",
//t    "conditional_expression : logical_or_expression",
//t    "conditional_expression : logical_or_expression QUESTION expression COLON expression",
//t    "logical_or_expression : logical_and_expression",
//t    "logical_or_expression : logical_or_expression BAR2 logical_and_expression",
//t    "logical_and_expression : bitwise_or_expression",
//t    "logical_and_expression : logical_and_expression AND2 bitwise_or_expression",
//t    "bitwise_or_expression : bitwise_and_expression",
//t    "bitwise_or_expression : bitwise_or_expression BAR bitwise_and_expression",
//t    "bitwise_and_expression : equality_expression",
//t    "bitwise_and_expression : bitwise_and_expression AND equality_expression",
//t    "equality_expression : relational_expression",
//t    "equality_expression : equality_expression EQUAL2 relational_expression",
//t    "equality_expression : equality_expression EXCLAIM_EQUAL relational_expression",
//t    "relational_expression : shift_expression",
//t    "relational_expression : relational_expression OPEN_ANGLE shift_expression",
//t    "relational_expression : relational_expression OPEN_ANGLE_EQUAL shift_expression",
//t    "relational_expression : relational_expression CLOSE_ANGLE shift_expression",
//t    "relational_expression : relational_expression CLOSE_ANGLE_EQUAL shift_expression",
//t    "shift_expression : additive_expression",
//t    "shift_expression : shift_expression OPEN_ANGLE2 additive_expression",
//t    "shift_expression : shift_expression CLOSE_ANGLE2 additive_expression",
//t    "logical_not_expression : EXCLAIM prefixed_unary_expression",
//t  };
//t public static string getRule (int index) {
//t    return yyRule [index];
//t }
//t}
  protected static readonly string [] yyNames = {    
    "end-of-file",null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,"ERROR","EOF","IDENTIFIER",
    "NUMERIC_LITERAL","STRING_LITERAL","COLOR_LITERAL",
    "CHARACTER_LITERAL","CLASS","EXTENDS","IMPLEMENTS","WHILE","BREAK",
    "CONTINUE","RETURN","IF","ELSE","FOR","SWITCH","CASE","DEFAULT","NEW",
    "TRUE","FALSE","THIS","SUPER","NULL","PLUS","MINUS","ASTERISK",
    "SLASH","PERCENT","PLUS_EQUAL","MINUS_EQUAL","ASTERISK_EQUAL",
    "SLASH_EQUAL","PERCENT_EQUAL","PLUS2","MINUS2","EQUAL","EQUAL2",
    "COMMA","DOT","COLON","SEMICOLON","QUESTION","EXCLAIM",
    "EXCLAIM_EQUAL","AND","AND2","BAR","BAR2","OPEN_CURLY","CLOSE_CURLY",
    "OPEN_PAREN","CLOSE_PAREN","OPEN_BRACE_CLOSE_BRACE","OPEN_BRACE",
    "CLOSE_BRACE","OPEN_ANGLE","OPEN_ANGLE2","OPEN_ANGLE_EQUAL",
    "CLOSE_ANGLE","CLOSE_ANGLE2","CLOSE_ANGLE_EQUAL",
  };

  /** index-checked interface to yyNames[].
      @param token single character or %token value.
      @return token name or [illegal] or [unknown].
    */
//t  public static string yyname (int token) {
//t    if ((token < 0) || (token > yyNames.Length)) return "[illegal]";
//t    string name;
//t    if ((name = yyNames[token]) != null) return name;
//t    return "[unknown]";
//t  }

  int yyExpectingState;
  /** computes list of expected tokens on error by tracing the tables.
      @param state for which to compute the list.
      @return list of token names.
    */
  protected int [] yyExpectingTokens (int state){
    int token, n, len = 0;
    bool[] ok = new bool[yyNames.Length];
    if ((n = yySindex[state]) != 0)
      for (token = n < 0 ? -n : 0;
           (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
        if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
          ++ len;
          ok[token] = true;
        }
    if ((n = yyRindex[state]) != 0)
      for (token = n < 0 ? -n : 0;
           (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
        if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
          ++ len;
          ok[token] = true;
        }
    int [] result = new int [len];
    for (n = token = 0; n < len;  ++ token)
      if (ok[token]) result[n++] = token;
    return result;
  }
  protected string[] yyExpecting (int state) {
    int [] tokens = yyExpectingTokens (state);
    string [] result = new string[tokens.Length];
    for (int n = 0; n < tokens.Length;  n++)
      result[n++] = yyNames[tokens [n]];
    return result;
  }

  /** the generated parser, with debugging messages.
      Maintains a state and a value stack, currently with fixed maximum size.
      @param yyLex scanner.
      @param yydebug debug message writer implementing yyDebug, or null.
      @return result of the last reduction, if any.
      @throws yyException on irrecoverable parse error.
    */
  internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
				 {
//t    this.debug = (yydebug.yyDebug)yyd;
    return yyparse(yyLex);
  }

  /** initial size and increment of the state/value stack [default 256].
      This is not final so that it can be overwritten outside of invocations
      of yyparse().
    */
  protected int yyMax;

  /** executed at the beginning of a reduce action.
      Used as $$ = yyDefault($1), prior to the user-specified action, if any.
      Can be overwritten to provide deep copy, etc.
      @param first value for $1, or null.
      @return first.
    */
  protected Object yyDefault (Object first) {
    return first;
  }

	static int[] global_yyStates;
	static object[] global_yyVals;
	protected bool use_global_stacks;
	object[] yyVals;					// value stack
	object yyVal;						// value stack ptr
	int yyToken;						// current input
	int yyTop;

  /** the generated parser.
      Maintains a state and a value stack, currently with fixed maximum size.
      @param yyLex scanner.
      @return result of the last reduction, if any.
      @throws yyException on irrecoverable parse error.
    */
  internal Object yyparse (yyParser.yyInput yyLex)
  {
    if (yyMax <= 0) yyMax = 256;		// initial size
    int yyState = 0;                   // state stack ptr
    int [] yyStates;               	// state stack 
    yyVal = null;
    yyToken = -1;
    int yyErrorFlag = 0;				// #tks to shift
	if (use_global_stacks && global_yyStates != null) {
		yyVals = global_yyVals;
		yyStates = global_yyStates;
   } else {
		yyVals = new object [yyMax];
		yyStates = new int [yyMax];
		if (use_global_stacks) {
			global_yyVals = yyVals;
			global_yyStates = yyStates;
		}
	}

    /*yyLoop:*/ for (yyTop = 0;; ++ yyTop) {
      if (yyTop >= yyStates.Length) {			// dynamically increase
        global::System.Array.Resize (ref yyStates, yyStates.Length+yyMax);
        global::System.Array.Resize (ref yyVals, yyVals.Length+yyMax);
      }
      yyStates[yyTop] = yyState;
      yyVals[yyTop] = yyVal;
//t      if (debug != null) debug.push(yyState, yyVal);

      /*yyDiscarded:*/ while (true) {	// discarding a token does not change stack
        int yyN;
        if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
          if (yyToken < 0) {
            yyToken = yyLex.advance() ? yyLex.token() : 0;
//t            if (debug != null)
//t              debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
          }
          if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
              && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
//t            if (debug != null)
//t              debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
            yyState = yyTable[yyN];		// shift to yyN
            yyVal = yyLex.value();
            yyToken = -1;
            if (yyErrorFlag > 0) -- yyErrorFlag;
            goto continue_yyLoop;
          }
          if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
              && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
            yyN = yyTable[yyN];			// reduce (yyN)
          else
            switch (yyErrorFlag) {
  
            case 0:
              yyExpectingState = yyState;
              // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
//t              if (debug != null) debug.error("syntax error");
              if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
              goto case 1;
            case 1: case 2:
              yyErrorFlag = 3;
              do {
                if ((yyN = yySindex[yyStates[yyTop]]) != 0
                    && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                    && yyCheck[yyN] == Token.yyErrorCode) {
//t                  if (debug != null)
//t                    debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                  yyState = yyTable[yyN];
                  yyVal = yyLex.value();
                  goto continue_yyLoop;
                }
//t                if (debug != null) debug.pop(yyStates[yyTop]);
              } while (-- yyTop >= 0);
//t              if (debug != null) debug.reject();
              throw new yyParser.yyException("irrecoverable syntax error");
  
            case 3:
              if (yyToken == 0) {
//t                if (debug != null) debug.reject();
                throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
              }
//t              if (debug != null)
//t                debug.discard(yyState, yyToken, yyname(yyToken),
//t  							yyLex.value());
              yyToken = -1;
              goto continue_yyDiscarded;		// leave stack alone
            }
        }
        int yyV = yyTop + 1-yyLen[yyN];
//t        if (debug != null)
//t          debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
        yyVal = yyV > yyTop ? null : yyVals[yyV]; // yyVal = yyDefault(yyV > yyTop ? null : yyVals[yyV]);
        switch (yyN) {
case 2:
#line 136 "ProcessingParser.jay"
  {
		yyVal = new AstRoot ();
	}
  break;
case 3:
  case_3();
  break;
case 7:
#line 156 "ProcessingParser.jay"
  {
		yyVal = new GlobalFunctionDefinition ((FunctionDefinition) yyVals[0+yyTop]);
	}
  break;
case 8:
  case_8();
  break;
case 9:
#line 173 "ProcessingParser.jay"
  { yyVal = null; }
  break;
case 11:
#line 178 "ProcessingParser.jay"
  { yyVal = null; }
  break;
case 13:
#line 186 "ProcessingParser.jay"
  {
		yyVal = yyVals[0+yyTop];
	}
  break;
case 14:
#line 193 "ProcessingParser.jay"
  {
	 	yyVal = yyVals[0+yyTop];
	 }
  break;
case 15:
  case_15();
  break;
case 16:
  case_16();
  break;
case 17:
#line 212 "ProcessingParser.jay"
  { yyVal = new MemberList (); }
  break;
case 18:
  case_18();
  break;
case 22:
#line 231 "ProcessingParser.jay"
  {
		yyVal = new FieldDefinition ((VariableDeclarations) yyVals[-1+yyTop]);
	}
  break;
case 23:
#line 237 "ProcessingParser.jay"
  {
		yyVal = new ConstructorDefinition ((FunctionBase) yyVals[0+yyTop]);
	}
  break;
case 24:
#line 244 "ProcessingParser.jay"
  {
		yyVal = new FunctionDefinition ((TypeInfo) yyVals[-1+yyTop], (FunctionBase) yyVals[0+yyTop]);
	}
  break;
case 25:
#line 251 "ProcessingParser.jay"
  {
		yyVal = new FunctionBase ((string) yyVals[-4+yyTop], (List<FunctionArgument>) yyVals[-2+yyTop], (StatementBlock) yyVals[0+yyTop]);
	}
  break;
case 26:
#line 255 "ProcessingParser.jay"
  { yyVal = new List<FunctionArgument> (); }
  break;
case 28:
  case_28();
  break;
case 29:
  case_29();
  break;
case 30:
  case_30();
  break;
case 31:
#line 291 "ProcessingParser.jay"
  {
		yyVal = Statement.Block (true, (List<Statement>) yyVals[-1+yyTop]);
	}
  break;
case 32:
#line 295 "ProcessingParser.jay"
  { yyVal = null; }
  break;
case 33:
  case_33();
  break;
case 34:
#line 305 "ProcessingParser.jay"
  { yyVal = yyVals[-1+yyTop]; }
  break;
case 43:
#line 323 "ProcessingParser.jay"
  {
		yyVal = Statement.CallExpression ((Expression) yyVals[0+yyTop]);
	}
  break;
case 54:
  case_54();
  break;
case 55:
  case_55();
  break;
case 56:
  case_56();
  break;
case 57:
  case_57();
  break;
case 58:
  case_58();
  break;
case 59:
  case_59();
  break;
case 60:
  case_60();
  break;
case 61:
#line 407 "ProcessingParser.jay"
  {
		yyVal = Statement.CallSuper ();
	}
  break;
case 62:
#line 414 "ProcessingParser.jay"
  {
		yyVal = Statement.Return ((Expression) yyVals[0+yyTop]);
	}
  break;
case 63:
#line 421 "ProcessingParser.jay"
  {
		yyVal = Statement.CallExpression ((Expression) yyVals[0+yyTop]);
	}
  break;
case 64:
#line 427 "ProcessingParser.jay"
  {
		yyVal = Expression.Assign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
	}
  break;
case 65:
#line 434 "ProcessingParser.jay"
  {
		yyVal = Statement.Loop ((Expression) yyVals[-2+yyTop], (StatementBlock) yyVals[0+yyTop]);
	}
  break;
case 66:
#line 437 "ProcessingParser.jay"
  { yyVal = Statement.Break (); }
  break;
case 67:
#line 439 "ProcessingParser.jay"
  { yyVal = Statement.Continue (); }
  break;
case 68:
  case_68();
  break;
case 69:
  case_69();
  break;
case 70:
#line 467 "ProcessingParser.jay"
  {
		yyVal = new TypeInfo ((string) yyVals[-1+yyTop], (int) yyVals[0+yyTop]);
	}
  break;
case 71:
#line 474 "ProcessingParser.jay"
  {
		yyVal = 0;
	}
  break;
case 74:
#line 482 "ProcessingParser.jay"
  {
		yyVal = 1 + (int) yyVals[-1+yyTop];
	}
  break;
case 75:
#line 488 "ProcessingParser.jay"
  {
		yyVal = 1;
	}
  break;
case 76:
  case_76();
  break;
case 77:
  case_77();
  break;
case 78:
  case_78();
  break;
case 79:
#line 516 "ProcessingParser.jay"
  { yyVal = null; }
  break;
case 80:
#line 517 "ProcessingParser.jay"
  { yyVal = yyVals[0+yyTop]; }
  break;
case 81:
#line 518 "ProcessingParser.jay"
  { yyVal = yyVals[0+yyTop]; }
  break;
case 82:
  case_82();
  break;
case 83:
#line 528 "ProcessingParser.jay"
  { yyVal = new List<Expression> (); }
  break;
case 85:
  case_85();
  break;
case 86:
  case_86();
  break;
case 87:
#line 551 "ProcessingParser.jay"
  {
		yyVal = Statement.Block (false, (Statement) yyVals[0+yyTop]);
	}
  break;
case 89:
  case_89();
  break;
case 90:
#line 567 "ProcessingParser.jay"
  { yyVal = null; }
  break;
case 92:
#line 571 "ProcessingParser.jay"
  { yyVal = yyVals[0+yyTop]; }
  break;
case 93:
#line 572 "ProcessingParser.jay"
  { yyVal = yyVals[0+yyTop]; }
  break;
case 94:
  case_94();
  break;
case 95:
#line 589 "ProcessingParser.jay"
  { yyVal = null; }
  break;
case 96:
  case_96();
  break;
case 98:
  case_98();
  break;
case 101:
#line 616 "ProcessingParser.jay"
  { yyVal = null; }
  break;
case 103:
#line 627 "ProcessingParser.jay"
  {
		yyVal = Statement.Switch ((Expression) yyVals[-4+yyTop], ((List<SwitchCase>) yyVals[-1+yyTop]).ToArray ());
	}
  break;
case 104:
#line 631 "ProcessingParser.jay"
  { yyVal = new List<SwitchCase> (); }
  break;
case 105:
  case_105();
  break;
case 108:
  case_108();
  break;
case 109:
  case_109();
  break;
case 117:
#line 686 "ProcessingParser.jay"
  {
		yyVal = Expression.MultiplyChecked ((Expression) yyVals[0+yyTop], Expression.Constant (-1));
	}
  break;
case 127:
#line 703 "ProcessingParser.jay"
  {
		yyVal = Expression.Constant (yyVals[0+yyTop]);
	}
  break;
case 128:
#line 707 "ProcessingParser.jay"
  {
		yyVal = Expression.ColorConstant ((string) yyVals[0+yyTop]);
	}
  break;
case 129:
#line 714 "ProcessingParser.jay"
  {
		yyVal = Expression.IdentifierReference ((string) yyVals[0+yyTop]);
	}
  break;
case 132:
  case_132();
  break;
case 133:
#line 736 "ProcessingParser.jay"
  {
		yyVal = Expression.NewArrayBounds ((TypeInfo) yyVals[-1+yyTop], (List<Expression>) yyVals[0+yyTop]);
	}
  break;
case 134:
  case_134();
  break;
case 135:
  case_135();
  break;
case 136:
#line 757 "ProcessingParser.jay"
  {
		yyVal = yyVals[-1+yyTop];
	}
  break;
case 137:
#line 761 "ProcessingParser.jay"
  {
		yyVal = null;
	}
  break;
case 142:
  case_142();
  break;
case 143:
#line 783 "ProcessingParser.jay"
  {
		yyVal = new FunctionCall ((string) yyVals[-3+yyTop], (List<Expression>) yyVals[-1+yyTop]);
	}
  break;
case 144:
#line 787 "ProcessingParser.jay"
  { yyVal = new List<Expression> (); }
  break;
case 146:
  case_146();
  break;
case 147:
  case_147();
  break;
case 153:
#line 814 "ProcessingParser.jay"
  { yyVal = true; }
  break;
case 154:
#line 816 "ProcessingParser.jay"
  { yyVal = false; }
  break;
case 160:
#line 831 "ProcessingParser.jay"
  { yyVal = Expression.AddChecked ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 161:
#line 833 "ProcessingParser.jay"
  { yyVal = Expression.SubtractChecked ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 163:
#line 838 "ProcessingParser.jay"
  { yyVal = Expression.MultiplyChecked ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 164:
#line 840 "ProcessingParser.jay"
  { yyVal = Expression.DivideChecked ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 165:
#line 842 "ProcessingParser.jay"
  { yyVal = Expression.ModuloChecked ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 166:
#line 846 "ProcessingParser.jay"
  { yyVal = Expression.PropertyOrField ((Expression) yyVals[-2+yyTop], (string) yyVals[0+yyTop]); }
  break;
case 167:
  case_167();
  break;
case 168:
#line 861 "ProcessingParser.jay"
  {
		yyVal = Expression.Super ();
	}
  break;
case 169:
#line 868 "ProcessingParser.jay"
  {
		yyVal = Expression.This ();
	}
  break;
case 170:
#line 875 "ProcessingParser.jay"
  {
		yyVal = Expression.ArrayAccess ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop]);
	}
  break;
case 171:
#line 878 "ProcessingParser.jay"
  { yyVal = Expression.Null (); }
  break;
case 172:
#line 880 "ProcessingParser.jay"
  { yyVal = Expression.Parenthesized ((Expression) yyVals[-1+yyTop]); }
  break;
case 173:
#line 886 "ProcessingParser.jay"
  {
		yyVal = Expression.Cast ((TypeInfo) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
	}
  break;
case 175:
#line 892 "ProcessingParser.jay"
  { yyVal = Expression.Condition ((Expression) yyVals[-4+yyTop], (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 177:
#line 897 "ProcessingParser.jay"
  { yyVal = Expression.OrElse ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 179:
#line 902 "ProcessingParser.jay"
  { yyVal = Expression.AndAlso ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 181:
#line 907 "ProcessingParser.jay"
  { yyVal = Expression.Or ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 183:
#line 912 "ProcessingParser.jay"
  { yyVal = Expression.And ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 185:
#line 919 "ProcessingParser.jay"
  {
		yyVal = Expression.Equal ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
	}
  break;
case 186:
#line 923 "ProcessingParser.jay"
  {
		yyVal = Expression.NotEqual ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
	}
  break;
case 188:
#line 928 "ProcessingParser.jay"
  { yyVal = Expression.LessThan ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 189:
#line 930 "ProcessingParser.jay"
  { yyVal = Expression.LessThanOrEqual ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 190:
#line 932 "ProcessingParser.jay"
  { yyVal = Expression.GreaterThan ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 191:
#line 934 "ProcessingParser.jay"
  { yyVal = Expression.GreaterThanOrEqual ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 193:
#line 940 "ProcessingParser.jay"
  { yyVal = Expression.LeftShift ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 194:
#line 942 "ProcessingParser.jay"
  { yyVal = Expression.RightShift ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]); }
  break;
case 195:
#line 947 "ProcessingParser.jay"
  { yyVal = Expression.Not ((Expression) yyVals[0+yyTop]); }
  break;
#line default
        }
        yyTop -= yyLen[yyN];
        yyState = yyStates[yyTop];
        int yyM = yyLhs[yyN];
        if (yyState == 0 && yyM == 0) {
//t          if (debug != null) debug.shift(0, yyFinal);
          yyState = yyFinal;
          if (yyToken < 0) {
            yyToken = yyLex.advance() ? yyLex.token() : 0;
//t            if (debug != null)
//t               debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
          }
          if (yyToken == 0) {
//t            if (debug != null) debug.accept(yyVal);
            return yyVal;
          }
          goto continue_yyLoop;
        }
        if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
            && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
          yyState = yyTable[yyN];
        else
          yyState = yyDgoto[yyM];
//t        if (debug != null) debug.shift(yyStates[yyTop], yyState);
	 goto continue_yyLoop;
      continue_yyDiscarded: ;	// implements the named-loop continue: 'continue yyDiscarded'
      }
    continue_yyLoop: ;		// implements the named-loop continue: 'continue yyLoop'
    }
  }

/*
 All more than 3 lines long rules are wrapped into a method
*/
void case_3()
#line 138 "ProcessingParser.jay"
{
		var r = (AstRoot) yyVals[0+yyTop];
		r.Items.Insert (0, (ITopLevelContent) yyVals[-1+yyTop]);
		yyVal = r;
	}

void case_8()
#line 163 "ProcessingParser.jay"
{
		var name = (string) yyVals[-5+yyTop];
		var baseType = (TypeInfo) yyVals[-4+yyTop];
		var interfaces = (List<TypeInfo>) yyVals[-3+yyTop];
		var members = (MemberList) yyVals[-1+yyTop];
		yyVal = new ClassDefinition (name, baseType, interfaces, members);
	}

void case_15()
#line 198 "ProcessingParser.jay"
{
		var l = new List<TypeInfo> ();
		l.Add ((TypeInfo) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_16()
#line 204 "ProcessingParser.jay"
{
		var l = (List<TypeInfo>) yyVals[0+yyTop];
		l.Insert (0, (TypeInfo) yyVals[-2+yyTop]);
		yyVal = l;
	}

void case_18()
#line 214 "ProcessingParser.jay"
{
		var l = (MemberList) yyVals[-1+yyTop];
		l.Add ((MemberDefinition) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_28()
#line 260 "ProcessingParser.jay"
{
		var l = new List<FunctionArgument> ();
		l.Add ((FunctionArgument) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_29()
#line 266 "ProcessingParser.jay"
{
		var l = (List<FunctionArgument>) yyVals[-2+yyTop];
		l.Add ((FunctionArgument) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_30()
#line 275 "ProcessingParser.jay"
{
		/* FIXME: this causes gmcs invalid IL*/
		/* $$ = new FunctionArgument () { Type = (TypeInfo) $1, Name = (string) $2};*/
		var fa = new FunctionArgument ();
		fa.Type = (TypeInfo) yyVals[-1+yyTop];
		fa.Name = (string) yyVals[0+yyTop];
		yyVal = fa;
	}

void case_33()
#line 297 "ProcessingParser.jay"
{
		var l = (List<Statement>) yyVals[0+yyTop] ?? new List<Statement> ();
		l.Insert (0, (Statement) yyVals[-1+yyTop]);
		yyVal = l;
	}

void case_54()
#line 344 "ProcessingParser.jay"
{
		var e1 = (Expression) yyVals[-2+yyTop];
		var e2 = (Expression) yyVals[0+yyTop];
		yyVal = Statement.CallExpression (Expression.Assign (e1, Expression.AddChecked (e1, e2)));
	}

void case_55()
#line 353 "ProcessingParser.jay"
{
		var e1 = (Expression) yyVals[-2+yyTop];
		var e2 = (Expression) yyVals[0+yyTop];
		yyVal = Statement.CallExpression (Expression.Assign (e1, Expression.SubtractChecked (e1, e2)));
	}

void case_56()
#line 362 "ProcessingParser.jay"
{
		var e1 = (Expression) yyVals[-2+yyTop];
		var e2 = (Expression) yyVals[0+yyTop];
		yyVal = Statement.CallExpression (Expression.Assign (e1, Expression.MultiplyChecked (e1, e2)));
	}

void case_57()
#line 371 "ProcessingParser.jay"
{
		var e1 = (Expression) yyVals[-2+yyTop];
		var e2 = (Expression) yyVals[0+yyTop];
		yyVal = Statement.CallExpression (Expression.Assign (e1, Expression.DivideChecked (e1, e2)));
	}

void case_58()
#line 380 "ProcessingParser.jay"
{
		var e1 = (Expression) yyVals[-2+yyTop];
		var e2 = (Expression) yyVals[0+yyTop];
		yyVal = Statement.CallExpression (Expression.Assign (e1, Expression.ModuloChecked (e1, e2)));
	}

void case_59()
#line 389 "ProcessingParser.jay"
{
		var e1 = (Expression) yyVals[-1+yyTop];
		yyVal = Expression.Assign (e1, Expression.AddChecked (e1, Expression.Constant (1)));
	}

void case_60()
#line 397 "ProcessingParser.jay"
{
		var e1 = (Expression) yyVals[-1+yyTop];
		yyVal = Expression.Assign (e1, Expression.SubtractChecked (e1, Expression.Constant (1)));
	}

void case_68()
#line 445 "ProcessingParser.jay"
{
		var l = new List<Statement> ();
		var v = (VariableDeclarations) yyVals[0+yyTop];
		foreach (VariableDeclarationPair p in v.Pairs)
			l.Add (Statement.DeclareVariable (v.Type, p.Name, p.Initializer));
		yyVal = Statement.Block (false, l);
	}

void case_69()
#line 455 "ProcessingParser.jay"
{
		var v = new VariableDeclarations ();
		v.Type = (TypeInfo) yyVals[-1+yyTop];
		v.Pairs = (List<VariableDeclarationPair>) yyVals[0+yyTop];
		yyVal = v;
	}

void case_76()
#line 492 "ProcessingParser.jay"
{
		var l = new List<VariableDeclarationPair> ();
		l.Add ((VariableDeclarationPair) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_77()
#line 498 "ProcessingParser.jay"
{
		var l = (List<VariableDeclarationPair>) yyVals[-2+yyTop];
		l.Add ((VariableDeclarationPair) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_78()
#line 507 "ProcessingParser.jay"
{
		/* FIXME: gmcs bug, this causes invalid IL (if it is valid; field initializer causes the issue)*/
		/* $$ = new VariableDeclarationPair () {Name = (string) $1, Initializer = (Expression) $2};*/
		var vd = new VariableDeclarationPair ((string) yyVals[-1+yyTop], (Expression) yyVals[0+yyTop]);
		yyVal = vd;
	}

void case_82()
#line 522 "ProcessingParser.jay"
{
		var l = (List<Expression>) yyVals[-1+yyTop];
		yyVal = new ArrayInitializerExpression (l);
	}

void case_85()
#line 533 "ProcessingParser.jay"
{
		var l = new List<Expression> ();
		l.Add ((Expression) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_86()
#line 539 "ProcessingParser.jay"
{
		var l = (List<Expression>) yyVals[-2+yyTop];
		l.Add ((Expression) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_89()
#line 556 "ProcessingParser.jay"
{
		var cond = (Expression) yyVals[-3+yyTop];
		var tb = (StatementBlock) yyVals[-1+yyTop];
		var fb = (Statement) yyVals[0+yyTop];
		yyVal = fb != null ?
			Statement.IfThenElse (cond, tb, fb) :
			Statement.IfThen (cond, tb);
	}

void case_94()
#line 579 "ProcessingParser.jay"
{
		var init = (List<Statement>) yyVals[-6+yyTop];
		var cond = (Expression) yyVals[-4+yyTop];
		var cont = (Statement) yyVals[-2+yyTop];
		var body = (StatementBlock) yyVals[0+yyTop];
		yyVal = Statement.For (init, cond, cont, body);
	}

void case_96()
#line 591 "ProcessingParser.jay"
{
		if (yyVals[0+yyTop] is Statement) {
			var l = new List<Statement> ();
			l.Add ((Statement) yyVals[0+yyTop]);
			yyVal = l;
		}
		else
			yyVal = yyVals[0+yyTop];
	}

void case_98()
#line 604 "ProcessingParser.jay"
{
		var l = (List<Statement>) yyVals[-2+yyTop];
		l.Add ((Statement) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_105()
#line 634 "ProcessingParser.jay"
{
		var l = (List<SwitchCase>) yyVals[0+yyTop];
		l.Insert (0, (SwitchCase) yyVals[-1+yyTop]);
		yyVal = l;
	}

void case_108()
#line 648 "ProcessingParser.jay"
{
		var l = (List<Statement>) yyVals[0+yyTop];
		/* must end with break_statement*/
		if (!(l [l.Count - 1] is BreakStatement))
			l.Add (Statement.Break ());
		yyVal = new SwitchCase ((ConstantExpression) yyVals[-2+yyTop], l);
	}

void case_109()
#line 659 "ProcessingParser.jay"
{
		var l = (List<Statement>) yyVals[0+yyTop];
		/* must end with break_statement*/
		if (!(l [l.Count - 1] is BreakStatement))
			l.Add (Statement.Break ());
		yyVal = new DefaultCase (l);
	}

void case_132()
#line 726 "ProcessingParser.jay"
{
		var fcb = (FunctionCall) yyVals[0+yyTop];
		yyVal = Expression.New (new TypeInfo (fcb.Name, 0), fcb.Arguments);
	}

void case_134()
#line 741 "ProcessingParser.jay"
{
		var l = new List<Expression> ();
		l.Add ((Expression) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_135()
#line 747 "ProcessingParser.jay"
{
		var l = (List<Expression>) yyVals[-1+yyTop];
		l.Add ((Expression) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_142()
#line 774 "ProcessingParser.jay"
{
		var f = (FunctionCall) yyVals[0+yyTop];
		yyVal = Expression.Call (null, f.Name, f.Arguments);
	}

void case_146()
#line 793 "ProcessingParser.jay"
{
		var l = new List<Expression> ();
		l.Add ((Expression) yyVals[0+yyTop]);
		yyVal = l;
	}

void case_147()
#line 799 "ProcessingParser.jay"
{
		var l = (List<Expression>) yyVals[0+yyTop];
		l.Insert (0, (Expression) yyVals[-2+yyTop]);
		yyVal = l;
	}

void case_167()
#line 850 "ProcessingParser.jay"
{
		var inst = (Expression) yyVals[-2+yyTop];
		var f = (FunctionCall) yyVals[0+yyTop];
		yyVal = Expression.Call (inst, f.Name, f.Arguments);
	}

#line default
   static readonly short [] yyLhs  = {              -1,
    1,    0,    0,    2,    2,    2,    5,    4,    7,    7,
    8,    8,   10,   11,   13,   13,    9,    9,   14,   14,
   14,   15,   16,    6,   18,   19,   19,   21,   21,   22,
   20,   23,   23,    3,    3,   24,   24,   24,   24,   24,
   24,   31,   31,   25,   25,   25,   25,   32,   32,   32,
   32,   32,   32,   39,   40,   41,   42,   43,   46,   48,
   28,   26,   38,   50,   36,   29,   30,   27,   17,   12,
   52,   52,   53,   53,   54,   51,   51,   55,   56,   56,
   56,   57,   58,   58,   59,   59,   60,   60,   34,   61,
   61,   62,   62,   35,   63,   63,   65,   65,   66,   66,
   64,   64,   37,   67,   67,   68,   68,   69,   70,   45,
   45,   45,   72,   72,   72,   44,   44,   75,   75,   75,
   75,   75,   75,   75,   75,   75,   71,   71,   47,   81,
   81,   86,   87,   89,   89,   90,   90,   33,   33,   33,
   33,   91,   88,   49,   49,   93,   93,   84,   84,   84,
   84,   84,   97,   98,   96,   94,   85,   95,   99,   99,
   99,  100,  100,  100,  100,   79,   92,   74,   80,   82,
   78,   83,   77,   73,   73,  101,  101,  102,  102,  103,
  103,  104,  104,  105,  105,  105,  106,  106,  106,  106,
  106,  107,  107,  107,   76,
  };
   static readonly short [] yyLen = {           2,
    1,    0,    2,    1,    1,    1,    1,    7,    0,    1,
    0,    1,    2,    2,    1,    3,    0,    2,    1,    1,
    1,    2,    1,    2,    5,    0,    1,    1,    3,    2,
    3,    0,    2,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    3,    3,    3,    3,    3,    2,    2,
    4,    2,    1,    3,    5,    1,    1,    1,    2,    2,
    0,    1,    1,    2,    1,    1,    3,    2,    0,    2,
    2,    3,    0,    1,    1,    3,    1,    1,    6,    0,
    1,    2,    2,    9,    0,    1,    1,    3,    1,    1,
    0,    1,    7,    0,    2,    1,    1,    4,    3,    1,
    1,    1,    1,    1,    1,    1,    2,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    3,    1,    2,    3,    1,    1,    1,    1,
    1,    1,    4,    0,    1,    1,    3,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    3,
    3,    1,    3,    3,    3,    3,    3,    1,    1,    4,
    1,    3,    4,    1,    5,    1,    3,    1,    3,    1,
    3,    1,    3,    1,    3,    3,    1,    3,    3,    3,
    3,    1,    3,    3,    2,
  };
   static readonly short [] yyDefRed = {            0,
    1,  155,  156,  157,  158,    0,    0,   66,   67,    0,
    0,    0,    0,    0,  153,  154,  169,    0,  171,    0,
    0,    0,    0,    0,    0,    4,    5,    6,    7,    0,
   68,    0,   35,   36,   37,   38,   39,   40,   41,   42,
    0,   44,   45,   46,   47,   48,   49,   50,   51,   52,
   53,    0,  140,    0,  141,   63,  119,  116,    0,  114,
  115,  120,  121,  123,  124,  125,  126,  127,  128,  130,
  131,  142,  138,  139,  148,  149,  150,  151,  152,    0,
    0,  168,    0,  122,  162,   62,    0,  111,  112,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  132,    0,  117,  195,    0,    0,    0,
   75,   70,    0,   73,    3,    0,   24,    0,   76,   34,
    0,    0,    0,    0,    0,    0,   59,   60,    0,    0,
    0,    0,   10,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   99,  100,    0,    0,   97,    0,
  137,    0,    0,  134,    0,    0,  145,    0,  172,    0,
   74,    0,    0,   78,    0,   54,   55,   56,   57,   58,
   64,    0,  167,    0,    0,   13,    0,    0,   12,    0,
    0,    0,  163,  164,  165,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  135,    0,   61,  173,  143,    0,
   81,   80,    0,    0,    0,   28,   77,  170,    0,   14,
   17,    0,   65,    0,   87,   88,    0,    0,   98,    0,
  136,  147,   85,    0,    0,   30,    0,    0,    0,    0,
    0,    0,  175,    0,   89,   91,    0,    0,    0,    0,
    0,  106,  107,   82,    0,   25,   29,   16,    8,    0,
   21,   18,   19,   20,    0,   23,   33,   31,   44,   93,
  102,    0,    0,    0,  103,  105,   86,   22,    0,    0,
  109,   94,  108,
  };
  protected static readonly short [] yyDgoto  = {            23,
   83,   25,  251,   27,   28,   29,  132,  188,  250,  133,
  189,  154,  230,  272,  273,  274,   31,  117,  224,  236,
  225,  226,  252,   32,   33,   34,   35,   36,   37,   38,
   39,   40,   84,   42,   43,   44,   45,   46,   47,   48,
   49,   50,   51,   85,  165,   53,   54,   55,  166,   56,
  118,  112,  113,  114,  119,  174,  222,  244,  245,  237,
  255,  256,  157,  282,  158,  159,  260,  261,  262,  263,
   57,   58,   88,   89,   59,   60,   61,   62,   63,   64,
   65,   66,   67,   68,   69,   70,   71,   72,  163,  164,
   73,   74,  167,   75,   76,   77,   78,   79,   90,   91,
   92,   93,   94,   95,   96,   97,   98,
  };
  protected static readonly short [] yySindex = {          159,
    0,    0,    0,    0,    0, -248, -288,    0,    0, -181,
 -256, -239, -226, -248,    0,    0,    0, -221,    0,  -79,
  -79, -181,    0, -255,  159,    0,    0,    0,    0, -248,
    0, -259,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  -73,    0, -171,    0,    0,    0,    0, -269,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -231,
 -181,    0, -206,    0,    0,    0,    0,    0,    0, -149,
 -159, -276, -258, -192, -188, -273,  -78, -266, -181,  -79,
 -181, -255, -150,    0, -181,    0,    0, -193, -191, -181,
    0,    0, -182,    0,    0, -243,    0, -165,    0,    0,
 -181, -181, -181, -181, -181, -181,    0,    0, -248, -181,
 -248, -130,    0, -160,  -79,  -79,  -79,  -79,  -79, -181,
  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
  -79,  -79, -147, -248,    0,    0, -134, -129,    0, -135,
    0, -181, -150,    0, -119, -120,    0,  -79,    0, -118,
    0, -242, -248,    0, -248,    0,    0,    0,    0,    0,
    0, -206,    0, -117, -182,    0, -248,  -98,    0,  -88,
 -159, -159,    0,    0,    0,  -86, -258, -192, -188, -273,
  -78,  -78, -266, -266, -266, -266, -149, -149,  213,  -71,
 -181,  -79,  -82,  -84,    0, -181,    0,    0,    0, -181,
    0,    0, -248,  -75,  -65,    0,    0,    0,  -64,    0,
    0,  265,    0, -181,    0,    0,  -34,  -59,    0, -122,
    0,    0,    0,  -63,  -53,    0,  -88, -248, -248, -244,
  265,  -62,    0,  213,    0,    0,  -79, -154,  -54,  -61,
 -122,    0,    0,    0, -181,    0,    0,    0,    0, -225,
    0,    0,    0,    0,  -51,    0,    0,    0,    0,    0,
    0,  -57,  -40,  265,    0,    0,    0,    0,  -88,  265,
    0,    0,    0,
  };
  protected static readonly short [] yyRindex = {          266,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -146,  266,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   87,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  331,    0,    0,    0,    0,  445,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -257,
    0,    0,  293,    0,    0,    0,  483,    0,    0,  595,
  512, -223, -105,  151,  827,   19,  203,  670,    0,  -27,
    0,  -29,    0,    0,  -24,    0,    0,    0,    0,  -24,
    0,    0, -252,    0,    0, -228,    0,  -12,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  -19,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   -9,    0,    0,
    0,    0,  407,    0,  -18,    0,    0,    0,    0,    0,
    0,    0,  -17,    0,    0,    0,    0,    0,    0,    0,
    0,  369,    0,    0, -233,    0,    0,    0,    0,    0,
  541,  570,    0,    0,    0,    0,  875,  859,  843,  811,
  255,  795,  695,  720,  745,  770,  620,  645,    0, -228,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   -8,
    0,    0,    0,    0,  -11,    0,    0,    0,   -4,    0,
    0,   -3,    0,    0,    0,    0,    1,    0,    0,   -1,
    0,    0,    0,    0,    4,    0,    0,    0,    0,    0,
 -263,    0,    0,    0,    0,    0,   -6,    0,    0,    0,
   -1,    0,    0,    0,    0,    0,    0,    0,    0,   68,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -263,    0,    0,    0,    0,    0, -263,
    0,    0,    0,
  };
  protected static readonly short [] yyGindex = {          292,
    2,    0,    3,    0,    0,   71,    0,    0,    0,    0,
    0,   48,   80,    0,    0,    0,   81,   85,    0, -184,
    0,   88, -241,    0,    0,    0, -100,    0,    0,    0,
   82,  -95,   58,   83,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   90,  285,    0,    0,    0,  230,    0,
    0,    0,    0,  232,  171,    0,    0,    0,    0,   95,
    0,    0,    0,    0,    0,  138,   91,    0,    0,    0,
   93,  233,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  -10,    0,  190,
    0,    0,  144,    0,    0,    0,    0,    0,   34,   52,
    0,  220,  222,  219,  221,   62,  -55,
  };
  protected static readonly short [] yyTable = {           155,
   90,   24,   26,  104,  156,  233,   72,   80,    9,  277,
    1,   32,   32,   72,    1,  102,    1,    2,    3,    4,
    5,   81,  145,   24,  140,   71,   24,   26,  129,  146,
  141,  116,   71,  131,   14,   15,   16,   17,   82,   19,
  120,   20,  291,  130,   72,   32,  142,   30,  293,  151,
    9,  172,  152,   99,  110,   72,  111,   41,   72,   21,
   72,  103,  266,   71,  269,  220,  173,   22,   79,  108,
  100,   79,   30,  174,   71,  174,  174,    1,    2,    3,
    4,    5,   41,  101,  173,  174,  111,  174,  105,   52,
  174,  203,  204,  205,  206,   14,   15,   16,   17,   82,
   19,   24,   20,  110,  292,    2,    3,    4,    5,  106,
  107,  155,   71,  143,   52,  144,  156,  168,  183,  169,
   21,  127,  128,   15,   16,  137,  138,  139,   22,  111,
  182,  175,  185,  135,  136,  187,  129,  129,  129,  129,
  129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
  190,  129,  258,  259,  129,  210,  129,  129,  129,  129,
  129,  161,  162,  209,   71,  211,  129,  212,  129,  129,
  129,  129,  129,  129,  185,  213,  210,  216,  186,    1,
    2,    3,    4,    5,  207,  208,  191,  192,  185,   52,
  217,  176,  219,  176,  176,  176,  228,   14,   15,   16,
   17,  176,   19,  176,   20,  176,  201,  202,  176,  231,
   24,  235,  234,   24,  121,  122,  123,  124,  125,  232,
  223,  126,   21,  172,  246,  240,  193,  194,  195,  241,
   22,  248,  249,   24,  229,  247,  147,  254,  148,  149,
  257,  150,   87,  265,  284,  264,  278,  285,  288,  185,
  185,  270,   24,  289,   87,   24,  235,  218,  290,   90,
   90,   90,   90,   90,   90,    2,   41,   90,   90,   90,
   90,   90,   95,   90,   90,   90,   90,   90,   90,   90,
   90,   90,   90,   71,   90,   24,  144,   69,   11,   41,
   96,   24,  146,   26,   86,  223,  229,   30,   52,   27,
   83,   52,   90,   15,  101,   32,  109,  104,   41,   90,
   90,   41,   84,   87,   41,  182,  115,  182,  182,  182,
  271,   52,  182,  182,  182,  182,   71,  182,  268,  182,
  275,   87,  182,   87,  276,  267,  279,   87,  281,  170,
   52,   41,   87,   52,  171,  227,   52,   41,  280,  239,
  283,  286,  215,   87,   87,   87,   87,   87,   87,  242,
  197,  199,   87,  198,  200,  134,    0,    0,    0,    0,
    0,    0,   87,   52,  122,  122,  122,  122,  122,   52,
    0,  122,    0,  153,  122,  160,   43,    0,    0,    0,
    0,    0,    0,    0,   87,    0,    0,   43,    0,  122,
    0,    0,    0,    0,   87,  176,  177,  178,  179,  180,
  181,    0,    0,    0,  184,    0,    0,    1,    2,    3,
    4,    5,    6,    0,  196,    7,    8,    9,   10,   11,
    0,   12,   13,    0,    0,   14,   15,   16,   17,   18,
   19,    0,   20,   87,    0,    0,  214,  178,   87,  178,
  178,  178,   87,    0,    0,  178,  221,  178,    0,  178,
   21,  178,    0,    0,  178,    0,   87,    0,   22,    0,
    0,    1,    2,    3,    4,    5,    0,    0,    0,    7,
    8,    9,   10,   11,    0,   12,   13,    0,    0,   14,
   15,   16,   17,   18,   19,  238,   20,   87,  184,  184,
    0,  184,  184,  184,  243,  184,  184,  184,  184,  184,
    0,  184,    0,  184,   21,    0,  184,    0,  253,    0,
  232,    0,   22,    1,    2,    3,    4,    5,    0,    0,
    0,    7,    8,    9,   10,   11,    0,   12,   13,    0,
    0,   14,   15,   16,   17,   18,   19,    0,   20,  287,
  185,  185,    0,  185,  185,  185,    0,  185,  185,  185,
  185,  185,    0,  185,    0,  185,   21,    0,  185,    0,
    0,    0,    0,    0,   22,  129,  129,  129,  129,  129,
  129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
  129,  129,  129,  129,    0,  129,  129,  129,  129,  129,
    0,  129,    0,  129,    0,  129,  129,  129,  129,  129,
  129,  129,  129,  118,  118,  118,  118,  118,  118,  118,
  118,  118,  118,    0,    0,  118,  118,  118,  118,  118,
  118,  118,    0,  118,  118,  118,  118,  118,    0,  118,
    0,  118,    0,  118,  118,  118,  118,  118,  118,  118,
  118,  166,  166,  166,  166,  166,  166,  166,  166,  166,
  166,    0,    0,  166,  166,  166,  166,  166,  166,  166,
    0,  166,  166,  166,  166,  166,    0,  166,    0,  166,
    0,  166,  166,  166,  166,  166,  166,  166,  166,  133,
  133,  133,  133,  133,  133,  133,  133,  133,  133,    0,
    0,  133,  133,  133,  133,  133,  133,  133,    0,  133,
  133,  133,  133,  133,    0,  133,    0,  133,    0,    0,
  133,  133,  133,  133,  133,  133,  133,  113,  113,  113,
  113,  113,  113,  113,  113,  113,  113,    0,    0,  113,
  113,  113,    0,  113,  113,  113,    0,  113,  113,  113,
  113,  113,    0,  113,    0,  113,    0,    0,  113,  113,
  113,  113,  113,  113,  113,  116,  116,  116,  116,  116,
    0,    0,    0,    0,    0,    0,    0,    0,  116,  110,
    0,  110,  110,  116,    0,  116,  116,  116,  116,  116,
    0,  110,    0,  110,  159,  159,  110,  116,  116,  116,
  116,  116,  116,    0,    0,    0,    0,  159,  159,    0,
  159,  159,  159,    0,  159,  159,  159,  159,  159,    0,
  159,    0,  159,  160,  160,  159,  159,  159,  159,  159,
  159,  159,    0,    0,    0,    0,  160,  160,    0,  160,
  160,  160,    0,  160,  160,  160,  160,  160,    0,  160,
    0,  160,  161,  161,  160,  160,  160,  160,  160,  160,
  160,    0,    0,    0,    0,  161,  161,    0,  161,  161,
  161,    0,  161,  161,  161,  161,  161,    0,  161,    0,
  161,    0,    0,  161,  161,  161,  161,  161,  161,  161,
  192,  192,    0,  192,  192,  192,    0,  192,  192,  192,
  192,  192,    0,  192,    0,  192,    0,    0,  192,  192,
  192,  192,  192,  192,  192,  193,  193,    0,  193,  193,
  193,    0,  193,  193,  193,  193,  193,    0,  193,    0,
  193,    0,    0,  193,  193,  193,  193,  193,  193,  193,
  194,  194,    0,  194,  194,  194,    0,  194,  194,  194,
  194,  194,    0,  194,    0,  194,    0,    0,  194,  194,
  194,  194,  194,  194,  194,  187,  187,    0,  187,  187,
  187,    0,  187,  187,  187,  187,  187,    0,  187,    0,
  187,    0,    0,  187,  187,    0,  187,  187,    0,  187,
  188,  188,    0,  188,  188,  188,    0,  188,  188,  188,
  188,  188,    0,  188,    0,  188,    0,    0,  188,  188,
    0,  188,  188,    0,  188,  189,  189,    0,  189,  189,
  189,    0,  189,  189,  189,  189,  189,    0,  189,    0,
  189,    0,    0,  189,  189,    0,  189,  189,    0,  189,
  190,  190,    0,  190,  190,  190,    0,  190,  190,  190,
  190,  190,    0,  190,    0,  190,    0,    0,  190,  190,
    0,  190,  190,    0,  190,  191,  191,    0,  191,  191,
  191,    0,  191,  191,  191,  191,  191,    0,  191,    0,
  191,    0,    0,  191,  191,    0,  191,  191,    0,  191,
  186,  186,    0,  186,  186,  186,    0,  186,  186,  186,
  186,  186,    0,  186,    0,  186,    0,  183,  186,  183,
  183,  183,    0,    0,  183,  183,  183,  183,    0,  183,
    0,  183,    0,  180,  183,  180,  180,  180,    0,    0,
    0,  180,  180,  180,    0,  180,    0,  180,    0,  181,
  180,  181,  181,  181,    0,    0,    0,  181,  181,  181,
    0,  181,    0,  181,    0,  179,  181,  179,  179,  179,
    0,    0,    0,  179,    0,  179,    0,  179,    0,  179,
    0,  177,  179,  177,  177,  177,    0,    0,    0,    0,
    0,  177,    0,  177,    0,  177,    0,    0,  177,
  };
  protected static readonly short [] yyCheck = {           100,
    0,    0,    0,   14,  100,  190,  259,    6,  266,  251,
  259,  275,  276,  266,  259,   14,  259,  260,  261,  262,
  263,  310,  296,   22,  301,  259,   25,   25,  298,  303,
  307,   30,  266,  265,  277,  278,  279,  280,  281,  282,
  300,  284,  284,  313,  297,  309,  305,    0,  290,  316,
  308,  295,  319,  310,  310,  308,  312,    0,  311,  302,
  313,   14,  247,  297,  309,  308,  310,  310,  297,   22,
  310,  300,   25,  297,  308,  299,  300,  259,  260,  261,
  262,  263,   25,  310,  310,  309,  312,  311,  310,    0,
  314,  147,  148,  149,  150,  277,  278,  279,  280,  281,
  282,  100,  284,  310,  289,  260,  261,  262,  263,   20,
   21,  212,  259,  306,   25,  304,  212,  311,  129,  311,
  302,  293,  294,  278,  279,  285,  286,  287,  310,  312,
  129,  297,  131,  283,  284,  266,  283,  284,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  311,  298,  275,  276,  301,  154,  303,  304,  305,  306,
  307,  312,  313,  311,  311,  300,  313,  297,  315,  316,
  317,  318,  319,  320,  173,  311,  175,  297,  131,  259,
  260,  261,  262,  263,  151,  152,  135,  136,  187,  100,
  311,  297,  311,  299,  300,  301,  314,  277,  278,  279,
  280,  307,  282,  309,  284,  311,  145,  146,  314,  308,
  209,  209,  299,  212,  288,  289,  290,  291,  292,  308,
  173,  295,  302,  295,  223,  308,  137,  138,  139,  314,
  310,  297,  297,  232,  187,  311,  315,  272,  317,  318,
  300,  320,   10,  297,  299,  309,  309,  309,  300,  248,
  249,  250,  251,  311,   22,  254,  254,  168,  299,  259,
  260,  261,  262,  263,  264,    0,  209,  267,  268,  269,
  270,  271,  300,  273,  274,  275,  276,  277,  278,  279,
  280,  281,  282,  313,  284,  284,  311,  300,  308,  232,
  300,  290,  311,  311,   10,  248,  249,  250,  209,  311,
  309,  212,  302,  308,  311,  309,   22,  309,  251,  309,
  310,  254,  309,   81,  257,  297,   25,  299,  300,  301,
  250,  232,  304,  305,  306,  307,  259,  309,  249,  311,
  250,   99,  314,  101,  250,  248,  254,  105,  257,  110,
  251,  284,  110,  254,  113,  175,  257,  290,  254,  212,
  258,  261,  163,  121,  122,  123,  124,  125,  126,  216,
  141,  143,  130,  142,  144,   81,   -1,   -1,   -1,   -1,
   -1,   -1,  140,  284,  288,  289,  290,  291,  292,  290,
   -1,  295,   -1,   99,  298,  101,  300,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  162,   -1,   -1,  311,   -1,  313,
   -1,   -1,   -1,   -1,  172,  121,  122,  123,  124,  125,
  126,   -1,   -1,   -1,  130,   -1,   -1,  259,  260,  261,
  262,  263,  264,   -1,  140,  267,  268,  269,  270,  271,
   -1,  273,  274,   -1,   -1,  277,  278,  279,  280,  281,
  282,   -1,  284,  211,   -1,   -1,  162,  297,  216,  299,
  300,  301,  220,   -1,   -1,  305,  172,  307,   -1,  309,
  302,  311,   -1,   -1,  314,   -1,  234,   -1,  310,   -1,
   -1,  259,  260,  261,  262,  263,   -1,   -1,   -1,  267,
  268,  269,  270,  271,   -1,  273,  274,   -1,   -1,  277,
  278,  279,  280,  281,  282,  211,  284,  265,  296,  297,
   -1,  299,  300,  301,  220,  303,  304,  305,  306,  307,
   -1,  309,   -1,  311,  302,   -1,  314,   -1,  234,   -1,
  308,   -1,  310,  259,  260,  261,  262,  263,   -1,   -1,
   -1,  267,  268,  269,  270,  271,   -1,  273,  274,   -1,
   -1,  277,  278,  279,  280,  281,  282,   -1,  284,  265,
  296,  297,   -1,  299,  300,  301,   -1,  303,  304,  305,
  306,  307,   -1,  309,   -1,  311,  302,   -1,  314,   -1,
   -1,   -1,   -1,   -1,  310,  283,  284,  285,  286,  287,
  288,  289,  290,  291,  292,  293,  294,  295,  296,  297,
  298,  299,  300,  301,   -1,  303,  304,  305,  306,  307,
   -1,  309,   -1,  311,   -1,  313,  314,  315,  316,  317,
  318,  319,  320,  283,  284,  285,  286,  287,  288,  289,
  290,  291,  292,   -1,   -1,  295,  296,  297,  298,  299,
  300,  301,   -1,  303,  304,  305,  306,  307,   -1,  309,
   -1,  311,   -1,  313,  314,  315,  316,  317,  318,  319,
  320,  283,  284,  285,  286,  287,  288,  289,  290,  291,
  292,   -1,   -1,  295,  296,  297,  298,  299,  300,  301,
   -1,  303,  304,  305,  306,  307,   -1,  309,   -1,  311,
   -1,  313,  314,  315,  316,  317,  318,  319,  320,  283,
  284,  285,  286,  287,  288,  289,  290,  291,  292,   -1,
   -1,  295,  296,  297,  298,  299,  300,  301,   -1,  303,
  304,  305,  306,  307,   -1,  309,   -1,  311,   -1,   -1,
  314,  315,  316,  317,  318,  319,  320,  283,  284,  285,
  286,  287,  288,  289,  290,  291,  292,   -1,   -1,  295,
  296,  297,   -1,  299,  300,  301,   -1,  303,  304,  305,
  306,  307,   -1,  309,   -1,  311,   -1,   -1,  314,  315,
  316,  317,  318,  319,  320,  283,  284,  285,  286,  287,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  296,  297,
   -1,  299,  300,  301,   -1,  303,  304,  305,  306,  307,
   -1,  309,   -1,  311,  283,  284,  314,  315,  316,  317,
  318,  319,  320,   -1,   -1,   -1,   -1,  296,  297,   -1,
  299,  300,  301,   -1,  303,  304,  305,  306,  307,   -1,
  309,   -1,  311,  283,  284,  314,  315,  316,  317,  318,
  319,  320,   -1,   -1,   -1,   -1,  296,  297,   -1,  299,
  300,  301,   -1,  303,  304,  305,  306,  307,   -1,  309,
   -1,  311,  283,  284,  314,  315,  316,  317,  318,  319,
  320,   -1,   -1,   -1,   -1,  296,  297,   -1,  299,  300,
  301,   -1,  303,  304,  305,  306,  307,   -1,  309,   -1,
  311,   -1,   -1,  314,  315,  316,  317,  318,  319,  320,
  296,  297,   -1,  299,  300,  301,   -1,  303,  304,  305,
  306,  307,   -1,  309,   -1,  311,   -1,   -1,  314,  315,
  316,  317,  318,  319,  320,  296,  297,   -1,  299,  300,
  301,   -1,  303,  304,  305,  306,  307,   -1,  309,   -1,
  311,   -1,   -1,  314,  315,  316,  317,  318,  319,  320,
  296,  297,   -1,  299,  300,  301,   -1,  303,  304,  305,
  306,  307,   -1,  309,   -1,  311,   -1,   -1,  314,  315,
  316,  317,  318,  319,  320,  296,  297,   -1,  299,  300,
  301,   -1,  303,  304,  305,  306,  307,   -1,  309,   -1,
  311,   -1,   -1,  314,  315,   -1,  317,  318,   -1,  320,
  296,  297,   -1,  299,  300,  301,   -1,  303,  304,  305,
  306,  307,   -1,  309,   -1,  311,   -1,   -1,  314,  315,
   -1,  317,  318,   -1,  320,  296,  297,   -1,  299,  300,
  301,   -1,  303,  304,  305,  306,  307,   -1,  309,   -1,
  311,   -1,   -1,  314,  315,   -1,  317,  318,   -1,  320,
  296,  297,   -1,  299,  300,  301,   -1,  303,  304,  305,
  306,  307,   -1,  309,   -1,  311,   -1,   -1,  314,  315,
   -1,  317,  318,   -1,  320,  296,  297,   -1,  299,  300,
  301,   -1,  303,  304,  305,  306,  307,   -1,  309,   -1,
  311,   -1,   -1,  314,  315,   -1,  317,  318,   -1,  320,
  296,  297,   -1,  299,  300,  301,   -1,  303,  304,  305,
  306,  307,   -1,  309,   -1,  311,   -1,  297,  314,  299,
  300,  301,   -1,   -1,  304,  305,  306,  307,   -1,  309,
   -1,  311,   -1,  297,  314,  299,  300,  301,   -1,   -1,
   -1,  305,  306,  307,   -1,  309,   -1,  311,   -1,  297,
  314,  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,
   -1,  309,   -1,  311,   -1,  297,  314,  299,  300,  301,
   -1,   -1,   -1,  305,   -1,  307,   -1,  309,   -1,  311,
   -1,  297,  314,  299,  300,  301,   -1,   -1,   -1,   -1,
   -1,  307,   -1,  309,   -1,  311,   -1,   -1,  314,
  };

#line 952 "ProcessingParser.jay"
} // end of class
#line default
namespace yydebug {
        using System;
	 internal interface yyDebug {
		 void push (int state, Object value);
		 void lex (int state, int token, string name, Object value);
		 void shift (int from, int to, int errorFlag);
		 void pop (int state);
		 void discard (int state, int token, string name, Object value);
		 void reduce (int from, int to, int rule, string text, int len);
		 void shift (int from, int to);
		 void accept (Object value);
		 void error (string message);
		 void reject ();
	 }
	 
	 class yyDebugSimple : yyDebug {
		 void println (string s){
			 Console.Error.WriteLine (s);
		 }
		 
		 public void push (int state, Object value) {
			 println ("push\tstate "+state+"\tvalue "+value);
		 }
		 
		 public void lex (int state, int token, string name, Object value) {
			 println("lex\tstate "+state+"\treading "+name+"\tvalue "+value);
		 }
		 
		 public void shift (int from, int to, int errorFlag) {
			 switch (errorFlag) {
			 default:				// normally
				 println("shift\tfrom state "+from+" to "+to);
				 break;
			 case 0: case 1: case 2:		// in error recovery
				 println("shift\tfrom state "+from+" to "+to
					     +"\t"+errorFlag+" left to recover");
				 break;
			 case 3:				// normally
				 println("shift\tfrom state "+from+" to "+to+"\ton error");
				 break;
			 }
		 }
		 
		 public void pop (int state) {
			 println("pop\tstate "+state+"\ton error");
		 }
		 
		 public void discard (int state, int token, string name, Object value) {
			 println("discard\tstate "+state+"\ttoken "+name+"\tvalue "+value);
		 }
		 
		 public void reduce (int from, int to, int rule, string text, int len) {
			 println("reduce\tstate "+from+"\tuncover "+to
				     +"\trule ("+rule+") "+text);
		 }
		 
		 public void shift (int from, int to) {
			 println("goto\tfrom state "+from+" to "+to);
		 }
		 
		 public void accept (Object value) {
			 println("accept\tvalue "+value);
		 }
		 
		 public void error (string message) {
			 println("error\t"+message);
		 }
		 
		 public void reject () {
			 println("reject");
		 }
		 
	 }
}
// %token constants
 class Token {
  public const int ERROR = 257;
  public const int EOF = 258;
  public const int IDENTIFIER = 259;
  public const int NUMERIC_LITERAL = 260;
  public const int STRING_LITERAL = 261;
  public const int COLOR_LITERAL = 262;
  public const int CHARACTER_LITERAL = 263;
  public const int CLASS = 264;
  public const int EXTENDS = 265;
  public const int IMPLEMENTS = 266;
  public const int WHILE = 267;
  public const int BREAK = 268;
  public const int CONTINUE = 269;
  public const int RETURN = 270;
  public const int IF = 271;
  public const int ELSE = 272;
  public const int FOR = 273;
  public const int SWITCH = 274;
  public const int CASE = 275;
  public const int DEFAULT = 276;
  public const int NEW = 277;
  public const int TRUE = 278;
  public const int FALSE = 279;
  public const int THIS = 280;
  public const int SUPER = 281;
  public const int NULL = 282;
  public const int PLUS = 283;
  public const int MINUS = 284;
  public const int ASTERISK = 285;
  public const int SLASH = 286;
  public const int PERCENT = 287;
  public const int PLUS_EQUAL = 288;
  public const int MINUS_EQUAL = 289;
  public const int ASTERISK_EQUAL = 290;
  public const int SLASH_EQUAL = 291;
  public const int PERCENT_EQUAL = 292;
  public const int PLUS2 = 293;
  public const int MINUS2 = 294;
  public const int EQUAL = 295;
  public const int EQUAL2 = 296;
  public const int COMMA = 297;
  public const int DOT = 298;
  public const int COLON = 299;
  public const int SEMICOLON = 300;
  public const int QUESTION = 301;
  public const int EXCLAIM = 302;
  public const int EXCLAIM_EQUAL = 303;
  public const int AND = 304;
  public const int AND2 = 305;
  public const int BAR = 306;
  public const int BAR2 = 307;
  public const int OPEN_CURLY = 308;
  public const int CLOSE_CURLY = 309;
  public const int OPEN_PAREN = 310;
  public const int CLOSE_PAREN = 311;
  public const int OPEN_BRACE_CLOSE_BRACE = 312;
  public const int OPEN_BRACE = 313;
  public const int CLOSE_BRACE = 314;
  public const int OPEN_ANGLE = 315;
  public const int OPEN_ANGLE2 = 316;
  public const int OPEN_ANGLE_EQUAL = 317;
  public const int CLOSE_ANGLE = 318;
  public const int CLOSE_ANGLE2 = 319;
  public const int CLOSE_ANGLE_EQUAL = 320;
  public const int yyErrorCode = 256;
 }
 namespace yyParser {
  using System;
  /** thrown for irrecoverable syntax errors and stack overflow.
    */
  internal class yyException : System.Exception {
    public yyException (string message) : base (message) {
    }
  }
  internal class yyUnexpectedEof : yyException {
    public yyUnexpectedEof (string message) : base (message) {
    }
    public yyUnexpectedEof () : base ("") {
    }
  }

  /** must be implemented by a scanner object to supply input to the parser.
    */
  internal interface yyInput {
    /** move on to next token.
        @return false if positioned beyond tokens.
        @throws IOException on input error.
      */
    bool advance (); // throws java.io.IOException;
    /** classifies current token.
        Should not be called if advance() returned false.
        @return current %token or single character.
      */
    int token ();
    /** associated with current token.
        Should not be called if advance() returned false.
        @return value for token().
      */
    Object value ();
  }
 }
} // close outermost namespace, that MUST HAVE BEEN opened in the prolog
