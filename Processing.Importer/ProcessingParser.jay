// To generate ProcessingParser.cs, use jay in mono/mcs/jay (run "make install" to install it first)
// as: jay -cv <skeleton.cs ProcessingParser.jay > ProcessingParser.cs

%{
using System;
using System.IO;
using System.Collections.Generic;
using ProcessingCli;
using ProcessingCli.Ast;

// Reference to MBR is generated by jay, but it is not supported in 2.1 corlib.
using MarshalByRefObject = System.Object;

namespace ProcessingCli.Parser
{

	public class ProcessingParser
	{
		ProcessingProjectSource source;
		int yacc_verbose_flag;

		public ProcessingParser (ProcessingProjectSource source)
		{
			this.source = source;
			Roots = new List<AstRoot> ();
		}

		public List<AstRoot> Roots { get; private set; }

		public void Parse ()
		{
			foreach (var uri in source.Sources) {
				var tr = source.OpenInput (uri);
				var t = new Tokenizer (uri, tr);
				try {
					//Roots.Add ((AstRoot) yyparse (t, new yydebug.yyDebugSimple ()));
					Roots.Add ((AstRoot) yyparse (t));
				} catch (yyParser.yyException ex) {
					throw new ParserException (String.Format ("Irrecoverable syntax error at {0}", t.Location), ex);
				}
			}
		}
%}

%token ERROR
%token EOF

%token IDENTIFIER
%token NUMERIC_LITERAL
%token STRING_LITERAL
%token COLOR_LITERAL
%token CHARACTER_LITERAL
%token CLASS			//"class"
%token EXTENDS			//"extends"
%token IMPLEMENTS		//"implements"
%token WHILE			//"while"
%token BREAK			//"break"
%token CONTINUE			//"continue"
%token RETURN			//"return"
%token IF			//"if"
%token ELSE			//"else"
%token FOR			//"for"
%token SWITCH			//"switch"
%token CASE			//"case"
%token DEFAULT			//"default"
%token NEW			//"new"
%token TRUE			//"true"
%token FALSE			//"false"
%token THIS			//"this"
%token SUPER			//"super"
%token NULL			//"null"
%token PLUS			//"+"
%token MINUS			//"-"
%token ASTERISK			//"*"
%token SLASH			//"/"
%token PERCENT			//"%"
%token PLUS_EQUAL		//"+="
%token MINUS_EQUAL		//"-="
%token ASTERISK_EQUAL		//"*="
%token SLASH_EQUAL		//"/="
%token PERCENT_EQUAL		//"%="
%token PLUS2			//"++"
%token MINUS2			//"--"
%token EQUAL			//"="
%token EQUAL2			//"=="
%token COMMA 			//","
%token DOT 			//"."
%token COLON 			//":"
%token SEMICOLON		//";"
%token QUESTION			//"?"
%token EXCLAIM			//"!"
%token EXCLAIM_EQUAL		//"!="
%token AND 			//"&"
%token AND2 			//"&&"
%token BAR			//"|"
%token BAR2			//"||"
%token OPEN_CURLY		//"{"
%token CLOSE_CURLY		//"}"
%token OPEN_PAREN		//"("
%token CLOSE_PAREN		//")"
%token OPEN_BRACE_CLOSE_BRACE	//"[" "]"
%token OPEN_BRACE		//"["
%token CLOSE_BRACE		//"]"
%token OPEN_ANGLE		//"<"
%token OPEN_ANGLE2		//"<<"
%token OPEN_ANGLE_EQUAL		//"<="
%token CLOSE_ANGLE		//">"
%token CLOSE_ANGLE2		//">>"
%token CLOSE_ANGLE_EQUAL	//">="

%left PLUS MINUS
%left ASTERISK SLASH PERCENT
%left EQUAL2 EXCLAIM_EQUAL
%left AND BAR
%left AND2 BAR2
%nonassoc PLUS2 MINUS2
%left QUESTION
%left COLON
%left DOT
%left OPEN_ANGLE OPEN_ANGLE_EQUAL CLOSE_ANGLE CLOSE_ANGLE_EQUAL
%left OPEN_ANGLE2 CLOSE_ANGLE2
%left OPEN_BRACE CLOSE_BRACE
%left OPEN_PAREN CLOSE_PAREN
%right EXCLAIM


%start top_level_contents
%%

identifier : IDENTIFIER

top_level_contents
	: // empty
	{
		$$ = new AstRoot ();
	}
	| top_level_content top_level_contents
	{
		var r = (AstRoot) $2;
		r.Items.Insert (0, (ITopLevelContent) $1);
		$$ = r;
	}
	;

top_level_content
	: statement
	| class_declaration
	| global_function_definition
	;


global_function_definition
	: function_definition
	{
		$$ = new GlobalFunctionDefinition ((FunctionDefinition) $1);
	}
	;

class_declaration
	: CLASS identifier
	  opt_derivation_indication opt_implementation_indications
	  OPEN_CURLY class_member_definitions CLOSE_CURLY
	{
		var name = (string) $2;
		var baseType = (TypeInfo) $3;
		var interfaces = (List<TypeInfo>) $4;
		var members = (MemberList) $6;
		$$ = new ClassDefinition (name, baseType, interfaces, members);
	}
	;

opt_derivation_indication
	: { $$ = null; } // empty
	| derivation_indication
	;

opt_implementation_indications
	: { $$ = null; } // empty
	| implementation_indications
	;

derivation_indication
	: EXTENDS type_name
	{
		$$ = $2;
	}
	;

implementation_indications
	 : IMPLEMENTS type_list
	 {
	 	$$ = $2;
	 }
	 ;

type_list
	: type_name
	{
		var l = new List<TypeInfo> ();
		l.Add ((TypeInfo) $1);
		$$ = l;
	}
	| type_name COMMA type_list
	{
		var l = (List<TypeInfo>) $3;
		l.Insert (0, (TypeInfo) $1);
		$$ = l;
	}
	;

class_member_definitions
	: { $$ = new MemberList (); } // empty
	| class_member_definitions class_member_definition
	{
		var l = (MemberList) $1;
		l.Add ((MemberDefinition) $2);
		$$ = l;
	}
	;

class_member_definition
	: field_definition
	| constructor_definition
	| function_definition
	;

field_definition
	: variable_declaration SEMICOLON
	{
		$$ = new FieldDefinition ((VariableDeclarations) $1);
	}

constructor_definition
	: function_definition_base
	{
		$$ = new ConstructorDefinition ((FunctionBase) $1);
	}
	;

function_definition
	: type_name function_definition_base
	{
		$$ = new FunctionDefinition ((TypeInfo) $1, (FunctionBase) $2);
	}
	;

function_definition_base
	: identifier OPEN_PAREN opt_argument_definitions CLOSE_PAREN statement_block
	{
		$$ = new FunctionBase ((string) $1, (List<FunctionArgument>) $3, (StatementBlock) $5);
	}
	;

opt_argument_definitions
	: { $$ = new List<FunctionArgument> (); } // empty
	| argument_definitions

argument_definitions
	: argument_definition
	{
		var l = new List<FunctionArgument> ();
		l.Add ((FunctionArgument) $1);
		$$ = l;
	}
	| argument_definitions COMMA argument_definition
	{
		var l = (List<FunctionArgument>) $1;
		l.Add ((FunctionArgument) $3);
		$$ = l;
	}
	;

argument_definition
	: type_name identifier
	{
		// FIXME: this causes gmcs invalid IL
		// $$ = new FunctionArgument () { Type = (TypeInfo) $1, Name = (string) $2};
		var fa = new FunctionArgument ();
		fa.Type = (TypeInfo) $1;
		fa.Name = (string) $2;
		$$ = fa;
	}
	;

// Statements

statement_block
	: OPEN_CURLY statements CLOSE_CURLY
	{
		$$ = Statement.Block (true, (List<Statement>) $2);
	}
	;

statements
	: { $$ = null; } // empty
	| statement statements
	{
		var l = (List<Statement>) $2 ?? new List<Statement> ();
		l.Insert (0, (Statement) $1);
		$$ = l;
	}
	;

statement
	: statement_with_semicolon SEMICOLON { $$ = $1; }
	| statement_without_semicolon
	;

statement_with_semicolon
	: return_statement
	| variable_declaration_statement
	| call_super_statement // FIXME: allow it only as a top of constructor body statements.
	| break_statement
	| continue_statement
	| flow_control_less_statement
	;

flow_control_less_statement
	: abstract_assignment_statement
	| callable_expression
	{
		$$ = Statement.CallExpression ((Expression) $1);
	}
	;

statement_without_semicolon
	: if_statement
	| for_statement
	| while_statement
	| switch_statement
	;

abstract_assignment_statement
	: assignment_statement
	| add_assignment_statement
	| subtract_assignment_statement
	| multiply_assignment_statement
	| divide_assignment_statement
	| modulo_assignment_statement
	;

add_assignment_statement
	: prefixed_unary_expression PLUS_EQUAL expression
	{
		var e1 = (Expression) $1;
		var e2 = (Expression) $3;
		$$ = Statement.CallExpression (Expression.Assign (e1, Expression.AddChecked (e1, e2)));
	}
	;

subtract_assignment_statement
	: prefixed_unary_expression MINUS_EQUAL expression
	{
		var e1 = (Expression) $1;
		var e2 = (Expression) $3;
		$$ = Statement.CallExpression (Expression.Assign (e1, Expression.SubtractChecked (e1, e2)));
	}
	;

multiply_assignment_statement
	: prefixed_unary_expression ASTERISK_EQUAL expression
	{
		var e1 = (Expression) $1;
		var e2 = (Expression) $3;
		$$ = Statement.CallExpression (Expression.Assign (e1, Expression.MultiplyChecked (e1, e2)));
	}
	;

divide_assignment_statement
	: prefixed_unary_expression SLASH_EQUAL expression
	{
		var e1 = (Expression) $1;
		var e2 = (Expression) $3;
		$$ = Statement.CallExpression (Expression.Assign (e1, Expression.DivideChecked (e1, e2)));
	}
	;

modulo_assignment_statement
	: prefixed_unary_expression PERCENT_EQUAL expression
	{
		var e1 = (Expression) $1;
		var e2 = (Expression) $3;
		$$ = Statement.CallExpression (Expression.Assign (e1, Expression.ModuloChecked (e1, e2)));
	}
	;

increment_expression
	: variable_or_member_reference PLUS2 // FIXME: no pre-positioned increment?
	{
		var e1 = (Expression) $1;
		$$ = Expression.Assign (e1, Expression.AddChecked (e1, Expression.Constant (1)));
	}
	;

decrement_expression
	: variable_or_member_reference MINUS2 // FIXME: no pre-positioned increment?
	{
		var e1 = (Expression) $1;
		$$ = Expression.Assign (e1, Expression.SubtractChecked (e1, Expression.Constant (1)));
	}
	;

call_super_statement
	: SUPER OPEN_PAREN function_args CLOSE_PAREN
	{
		$$ = Statement.CallSuper ();
	}
	;

return_statement
	: RETURN expression
	{
		$$ = Statement.Return ((Expression) $2);
	}
	;

assignment_statement
	: assignment_expression
	{
		$$ = Statement.CallExpression ((Expression) $1);
	}

assignment_expression
	: prefixed_unary_expression EQUAL expression
	{
		$$ = Expression.Assign ((Expression) $1, (Expression) $3);
	}
	;

while_statement
	: WHILE OPEN_PAREN expression CLOSE_PAREN statement_block
	{
		$$ = Statement.Loop ((Expression) $3, (StatementBlock) $5);
	}
	;

break_statement : BREAK { $$ = Statement.Break (); } ;

continue_statement : CONTINUE { $$ = Statement.Continue (); }

/// variable-declaration

variable_declaration_statement
	: variable_declaration
	{
		var l = new List<Statement> ();
		var v = (VariableDeclarations) $1;
		foreach (VariableDeclarationPair p in v.Pairs)
			l.Add (Statement.DeclareVariable (v.Type, p.Name, p.Initializer));
		$$ = Statement.Block (false, l);
	}

variable_declaration
	: type_name variable_declaration_pairs
	{
		var v = new VariableDeclarations ();
		v.Type = (TypeInfo) $1;
		v.Pairs = (List<VariableDeclarationPair>) $2;
		$$ = v;
	}
	;

type_name :
	identifier opt_array_indicators
	{
		$$ = new TypeInfo ((string) $1, (int) $2);
	}
	;

opt_array_indicators
	: // EMPTY
	{
		$$ = 0;
	}
	| array_indicators

array_indicators
	: array_indicator
	| array_indicators array_indicator
	{
		$$ = 1 + (int) $1;
	}

array_indicator
	: OPEN_BRACE_CLOSE_BRACE
	{
		$$ = 1;
	}

variable_declaration_pairs
	: variable_declaration_pair
	{
		var l = new List<VariableDeclarationPair> ();
		l.Add ((VariableDeclarationPair) $1);
		$$ = l;
	}
	| variable_declaration_pairs COMMA variable_declaration_pair
	{
		var l = (List<VariableDeclarationPair>) $1;
		l.Add ((VariableDeclarationPair) $3);
		$$ = l;
	}
	;

variable_declaration_pair
	: identifier opt_variable_initializer
	{
		// FIXME: gmcs bug, this causes invalid IL (if it is valid; field initializer causes the issue)
		// $$ = new VariableDeclarationPair () {Name = (string) $1, Initializer = (Expression) $2};
		var vd = new VariableDeclarationPair ((string) $1, (Expression) $2);
		$$ = vd;
	}
	;

opt_variable_initializer
	: { $$ = null; } // empty
	| EQUAL array_initializer { $$ = $2; }
	| EQUAL expression { $$ = $2; }

array_initializer
	: OPEN_CURLY opt_expression_list_comma CLOSE_CURLY
	{
		var l = (List<Expression>) $2;
		$$ = new ArrayInitializerExpression (l);
	}

opt_expression_list_comma
	: { $$ = new List<Expression> (); } // empty
	| expression_list_comma

expression_list_comma
	: expression
	{
		var l = new List<Expression> ();
		l.Add ((Expression) $1);
		$$ = l;
	}
	| expression_list_comma COMMA expression
	{
		var l = (List<Expression>) $1;
		l.Add ((Expression) $3);
		$$ = l;
	}

/// if-else

single_or_blocked_statements
	: statement
	{
		$$ = Statement.Block (false, (Statement) $1);
	}
	| statement_block

if_statement
	: IF OPEN_PAREN expression CLOSE_PAREN single_or_blocked_statements opt_else_block
	{
		var cond = (Expression) $3;
		var tb = (StatementBlock) $5;
		var fb = (Statement) $6;
		$$ = fb != null ?
			Statement.IfThenElse (cond, tb, fb) :
			Statement.IfThen (cond, tb);
	}
	;

opt_else_block
	: { $$ = null; } // empty
	| else_block

else_block
	: ELSE if_statement { $$ = $2; } // else if
	| ELSE single_or_blocked_statements { $$ = $2; } // else only

/// for

for_statement
	: FOR OPEN_PAREN opt_for_initializers SEMICOLON expression SEMICOLON
	for_continuation CLOSE_PAREN statement_block
	{
		var init = (List<Statement>) $3;
		var cond = (Expression) $5;
		var cont = (Statement) $7;
		var body = (StatementBlock) $9;
		$$ = Statement.For (init, cond, cont, body);
	}
	;

opt_for_initializers
	: { $$ = null; } // empty
	| for_initializers
	{
		if ($1 is Statement) {
			var l = new List<Statement> ();
			l.Add ((Statement) $1);
			$$ = l;
		}
		else
			$$ = $1;
	}

for_initializers
	: for_initializer
	| for_initializers COMMA for_initializer
	{
		var l = (List<Statement>) $1;
		l.Add ((Statement) $3);
		$$ = l;
	}

for_initializer
	: variable_declaration_statement
	| abstract_assignment_statement
	;

for_continuation
	: { $$ = null; } // EMPTY
	| flow_control_less_statement
	;

/// switch-case

switch_statement
	: SWITCH OPEN_PAREN expression CLOSE_PAREN
	  OPEN_CURLY switch_case_list CLOSE_CURLY
	{
		$$ = Statement.Switch ((Expression) $3, ((List<SwitchCase>) $6).ToArray ());
	}
	;

switch_case_list
	: { $$ = new List<SwitchCase> (); } // empty
	| switch_case_default switch_case_list
		// switch_default cannot appear twice
	{
		var l = (List<SwitchCase>) $2;
		l.Insert (0, (SwitchCase) $1);
		$$ = l;
	}
	;

switch_case_default
	: switch_case
	| switch_default
	;

switch_case
	: CASE constant_expression COLON statements
	{
		var l = (List<Statement>) $4;
		// must end with break_statement
		if (!(l [l.Count - 1] is BreakStatement))
			l.Add (Statement.Break ());
		$$ = new SwitchCase ((ConstantExpression) $2, l);
	}
	;

switch_default
	: DEFAULT COLON statements
	{
		var l = (List<Statement>) $3;
		// must end with break_statement
		if (!(l [l.Count - 1] is BreakStatement))
			l.Add (Statement.Break ());
		$$ = new DefaultCase (l);
	}
	;

// Expressions

expression
	: unary_expression
	| conditional_expression
	| super_expression
	;

unary_expression
	: primary_expression
	| logical_not_expression
	| cast_expression

prefixed_unary_expression
	: unary_expression
	| MINUS prefixed_unary_expression
	{
		$$ = Expression.MultiplyChecked ((Expression) $2, Expression.Constant (-1));
	}

primary_expression
	: variable_or_member_reference
	| constant_expression
	| null_expression
	| field_access_expression
	| callable_expression
	| this_expression
	| new_expression
	| array_access_expression
	| parenthesized_expression

constant_expression
	: raw_literal
	{
		$$ = Expression.Constant ($1);
	}
	| color_literal
	{
		$$ = Expression.ColorConstant ((string) $1);
	}
	;

variable_or_member_reference
	: identifier
	{
		$$ = Expression.IdentifierReference ((string) $1);
	}
	;

// new

new_expression
	: new_object_expression
	| new_array_expression
	;

new_object_expression
	: NEW function_call_base
	{
		var fcb = (FunctionCall) $2;
		$$ = Expression.New (new TypeInfo (fcb.Name, 0), fcb.Arguments);
	}
	;

new_array_expression
	: NEW type_name new_array_ranks
	{
		$$ = Expression.NewArrayBounds ((TypeInfo) $2, (List<Expression>) $3);
	}
	;

new_array_ranks
	: new_array_rank
	{
		var l = new List<Expression> ();
		l.Add ((Expression) $1);
		$$ = l;
	}
	| new_array_ranks new_array_rank
	{
		var l = (List<Expression>) $1;
		l.Add ((Expression) $2);
		$$ = l;
	}

new_array_rank
	: OPEN_BRACE expression CLOSE_BRACE
	{
		$$ = $2;
	}
	| OPEN_BRACE_CLOSE_BRACE
	{
		$$ = null;
	}

// callable expressions

callable_expression
	: function_call_expression
	| function_access_expression
	| increment_expression
	| decrement_expression
	;

function_call_expression
	: function_call_base
	{
		var f = (FunctionCall) $1;
		$$ = Expression.Call (null, f.Name, f.Arguments);
	}

function_call_base
	: identifier OPEN_PAREN function_args CLOSE_PAREN
	{
		$$ = new FunctionCall ((string) $1, (List<Expression>) $3);
	}
	;

function_args
	: { $$ = new List<Expression> (); } // empty
	| function_arg_list
	;

function_arg_list
	: expression
	{
		var l = new List<Expression> ();
		l.Add ((Expression) $1);
		$$ = l;
	}
	| expression COMMA function_arg_list
	{
		var l = (List<Expression>) $3;
		l.Insert (0, (Expression) $1);
		$$ = l;
	}
	;

raw_literal
	: string_literal
	| character_literal
	| numeric_literal
	| true_expression
	| false_expression
	;

true_expression : TRUE { $$ = true; } ;

false_expression : FALSE { $$ = false; } ;

numeric_literal : NUMERIC_LITERAL

string_literal : STRING_LITERAL

color_literal : COLOR_LITERAL

character_literal : CHARACTER_LITERAL

/// binary expressions

additive_expression
	: multiplicative_expression
	| additive_expression PLUS multiplicative_expression
	{ $$ = Expression.AddChecked ((Expression) $1, (Expression) $3); }
	| additive_expression MINUS multiplicative_expression
	{ $$ = Expression.SubtractChecked ((Expression) $1, (Expression) $3); }

multiplicative_expression
	: prefixed_unary_expression
	| multiplicative_expression ASTERISK prefixed_unary_expression
	{ $$ = Expression.MultiplyChecked ((Expression) $1, (Expression) $3); }
	| multiplicative_expression SLASH prefixed_unary_expression
	{ $$ = Expression.DivideChecked ((Expression) $1, (Expression) $3); }
	| multiplicative_expression PERCENT prefixed_unary_expression
	{ $$ = Expression.ModuloChecked ((Expression) $1, (Expression) $3); }

field_access_expression
	: primary_expression DOT identifier
	{ $$ = Expression.PropertyOrField ((Expression) $1, (string) $3); }

function_access_expression
	: primary_expression DOT function_call_base
	{
		var inst = (Expression) $1;
		var f = (FunctionCall) $3;
		$$ = Expression.Call (inst, f.Name, f.Arguments);
	}
	;

super_expression
	: SUPER
	{
		$$ = Expression.Super ();
	}
	;

this_expression
	: THIS
	{
		$$ = Expression.This ();
	}
	; // FIXME: how can I represent it?

array_access_expression
	: primary_expression OPEN_BRACE expression CLOSE_BRACE
	{
		$$ = Expression.ArrayAccess ((Expression) $1, (Expression) $3);
	}
	;

null_expression : NULL { $$ = Expression.Null (); };

parenthesized_expression : OPEN_PAREN expression CLOSE_PAREN { $$ = Expression.Parenthesized ((Expression) $2); };

cast_expression
	: OPEN_PAREN type_name CLOSE_PAREN prefixed_unary_expression
	{
		$$ = Expression.Cast ((TypeInfo) $2, (Expression) $4);
	}
	;

conditional_expression
	: logical_or_expression
	| logical_or_expression QUESTION expression COLON expression
	{ $$ = Expression.Condition ((Expression) $1, (Expression) $3, (Expression) $5); };

logical_or_expression
	: logical_and_expression
	| logical_or_expression BAR2 logical_and_expression
	{ $$ = Expression.OrElse ((Expression) $1, (Expression) $3); };

logical_and_expression
	: bitwise_or_expression
	| logical_and_expression AND2 bitwise_or_expression
	{ $$ = Expression.AndAlso ((Expression) $1, (Expression) $3); };

bitwise_or_expression 
	: bitwise_and_expression
	| bitwise_or_expression BAR bitwise_and_expression
	{ $$ = Expression.Or ((Expression) $1, (Expression) $3); };

bitwise_and_expression
	: equality_expression
	| bitwise_and_expression AND equality_expression
	{ $$ = Expression.And ((Expression) $1, (Expression) $3); };

equality_expression
	: relational_expression
	| equality_expression EQUAL2 relational_expression
	{
		$$ = Expression.Equal ((Expression) $1, (Expression) $3);
	}
	| equality_expression EXCLAIM_EQUAL relational_expression
	{
		$$ = Expression.NotEqual ((Expression) $1, (Expression) $3);
	}

relational_expression
	: shift_expression
	| relational_expression OPEN_ANGLE shift_expression
	{ $$ = Expression.LessThan ((Expression) $1, (Expression) $3); }
	| relational_expression OPEN_ANGLE_EQUAL shift_expression
	{ $$ = Expression.LessThanOrEqual ((Expression) $1, (Expression) $3); }
	| relational_expression CLOSE_ANGLE shift_expression
	{ $$ = Expression.GreaterThan ((Expression) $1, (Expression) $3); }
	| relational_expression CLOSE_ANGLE_EQUAL shift_expression
	{ $$ = Expression.GreaterThanOrEqual ((Expression) $1, (Expression) $3); }
	;

shift_expression
	: additive_expression
	| shift_expression OPEN_ANGLE2 additive_expression
	{ $$ = Expression.LeftShift ((Expression) $1, (Expression) $3); }
	| shift_expression CLOSE_ANGLE2 additive_expression
	{ $$ = Expression.RightShift ((Expression) $1, (Expression) $3); }
	;

logical_not_expression
	: EXCLAIM prefixed_unary_expression
	{ $$ = Expression.Not ((Expression) $2); };



%%
} // end of class
